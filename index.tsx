
import React, { useState, useMemo, useRef, useEffect } from 'react';
import { createRoot } from 'react-dom/client';
import { GoogleGenAI, Modality, Type } from "@google/genai";
import { v4 as uuidv4 } from 'uuid';

// This is a workaround for uuid not being in the import map.
// In a real project, you would add it to the import map.
const g = globalThis;
if (!g.uuidv4) {
    g.uuidv4 = function() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
            var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}


// --- CONSTANTS ---

const FONT_FAMILIES = [
    { name: 'Anton', value: "'Anton', sans-serif" },
    { name: 'Oswald', value: "'Oswald', sans-serif" },
    { name: 'Bebas Neue', value: "'Bebas Neue', cursive" },
    { name: 'Roboto Condensed', value: "'Roboto Condensed', sans-serif" },
    { name: 'Montserrat', value: "'Montserrat', sans-serif" },
    { name: 'Poppins', value: "'Poppins', sans-serif" },
    { name: 'Lobster', value: "'Lobster', cursive" },
    { name: 'Pacifico', value: "'Pacifico', cursive" },
    { name: 'Archivo Black', value: "'Archivo Black', sans-serif" },
    { name: 'Passion One', value: "'Passion One', cursive" },
    { name: 'Alfa Slab One', value: "'Alfa Slab One', cursive" },
    { name: 'Black Ops One', value: "'Black Ops One', cursive" },
    { name: 'Bangers', value: "'Bangers', cursive" },
    { name: 'Permanent Marker', value: "'Permanent Marker', cursive" },
    { name: 'Ultra', value: "'Ultra', serif" },
    { name: 'Luckiest Guy', value: "'Luckiest Guy', cursive" },
    { name: 'Righteous', value: "'Righteous', cursive" },
    { name: 'Staatliches', value: "'Staatliches', cursive" },
    { name: 'Patua One', value: "'Patua One', cursive" },
    { name: 'Changa', value: "'Changa', sans-serif" },
    { name: 'Inter', value: 'Inter, sans-serif' },
];

const VOICES = [
    { id: 'Zephyr', name: 'Feminina 1' },
    { id: 'Charon', name: 'Feminina 2' },
    { id: 'Kore', name: 'Masculina 1' },
    { id: 'Puck', name: 'Masculina 2' },
    { id: 'Fenrir', name: 'Masculina 3' },
];

const LANGUAGES: Record<string, {name: string}> = {
    'pt': { name: 'Português (Brasil)' },
    'en': { name: 'Inglês' },
    'es': { name: 'Espanhol' },
    'ar': { name: 'Árabe' },
    'fr': { name: 'Francês' },
    'hi': { name: 'Hindi' },
    'it': { name: 'Italiano' },
};

const LANGUAGE_TO_COUNTRIES_MAP: Record<string, { name: string, code: string }[]> = {
    'pt': [{ name: 'Brasil', code: 'BR' }, { name: 'Portugal', code: 'PT' }],
    'en': [{ name: 'EUA', code: 'US' }, { name: 'Reino Unido', code: 'GB' }, { name: 'Canadá', code: 'CA' }, { name: 'Austrália', code: 'AU' }],
    'es': [{ name: 'Espanha', code: 'ES' }, { name: 'México', code: 'MX' }, { name: 'Argentina', code: 'AR' }],
    'ar': [{ name: 'Arábia Saudita', code: 'SA' }, { name: 'Egito', code: 'EG' }],
    'fr': [{ name: 'França', code: 'FR' }],
    'hi': [{ name: 'Índia', code: 'IN' }],
    'it': [{ name: 'Itália', code: 'IT' }],
};

const FLAGS: Record<string, string> = {
    'BR': 'data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAAAQABAAD/2wCEAAoHCBYWFRgWFhYZGRgaHBwcHBwYGhwcHBwaHBocHBweHh4cIS4lHCErIRwcJjgmKy8xNTU1GiQ7QDs0Py40NTEBDAwMEA8QHhISHzQrJCs0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NP/AABEIAKkBNgMBIgACEQEDEQH/xAAYAAEBAQEBAAAAAAAAAAAAAAAAAQIDBf/EAB4QAQEBAQEBAQEBAQEAAAAAAABEQISAxMhQVFh/8QAGQEBAQEBAQEAAAAAAAAAAAAAAAECAwQG/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oADAMBAAIRAxEAAAD4AAAAEigAAAAAIsAAAAAEUAAAAAAAAAAAAgqUAAAAAAAABCpQAAAAAAAAAAAAgKAAAAAAAAAAAAEUAAAAAAAAAAAIqUAAAAAAACUAAAAACKgAAAAAAAACKlAAAAAAAAAAACKAAAAAAAAAAAAAAABFQAAAAAAAAAAAIqUAAAAAABCpQAAAAAAAACKlAAAAAAAACFQAAAAAAAAAAACKlAAAAAAAAACAAAAAAAAAAAAAIqUAAAAAIKgAAAAACKAAAAAAAABCpQAAAAAAAAgqAAAAAAAAAAAACKlAAAAAAAAAAAAAAgAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIKgAAAAAAACKlAAAAAAACKAAAAAAAABCpQAAAAAAAACKlAAAAAAgqAAAAAAIKlAAAAAACKAAAAAAAAAAgqUAAAAAIKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAIKgAAAAACKlAAAAAAAAAgqAAAAAAAAAAAACKlAAAAAAAAAAAAACKAAAAAAAACKlAAAAAgqUAAAAAAAIAAAAAAAACKlAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAAAIKgAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIKgAAAAAAACKlAAAAAAAACCoAAAAAAAAACCoAAAAAAAACCoAAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAACKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAAgqAAAAAAIKgAAAAAAACCoAAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAAgqAAAAAAAAAgqUAAAAAAAIAAAAAAAACCoAAAAAAAAAAgqAAAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAACKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAIKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAAAIAAAACUAAAAAAAAAqUAAAAAAAAIKgAAAAAAgqUAAAAAAAIKgAAAAAAAAACCoAAAAAAAACCoAAAAAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAAAACCoAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAAgqAAAAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAAgqUAAAAAAAIAAAAAAAACKlAAAAAAAACKgAAAAACKlAAAAAAAACKgAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACCoAAAAAAAACKlAAAAAAAACKgAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAAAIKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACoAAAAAAAAAAAAAAA//xAAUEAEAAAAAAAAAAAAAAAAAAABg/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAwEBPwEo/8QAFBEBAAAAAAAAAAAAAAAAAAAAYP/aAAgBAgEBPwEo/8QAPRAAAQICAgYJAwQCAwEBAAAAAQIDAB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VtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+oOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q',
    'PT': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAF/SURBVEhLzZbNSoNREEXP/2d22RggmGAm2A1sOo2bwKN4jeYtPAA3sWLjDYwtGOxYd4Exm5voBfqy2S2L6GgLmq6p6uH/39XdU7/fHxwOh39pNBqP0+kUe/0+mUzmcrk+n89isdgA7/V6vV4vGo0CgQDj8fjoGzAYDAaDARQKBQqFgsvlEgqFAoFAOBwGg8FlNBqDw2EwGC6n0wEHDofRaDTkcjmi0SgQCAQCgVKpBJfL5XA4zGaz2Ww2m83ncrlYLBYLgQDi8TgcDk+nUyaTMRgMZrPZbrfL5/NBIDCYzObz+UKh0Ol0mp1GrVZLpVKpVCqVSkmlUlKp1Gq12+0eHh5sNhucTqdarQaDwWQy2Ww2nU4Hgen1er1eLxgMsiLRaDSbzWaz2Ww2m83ms1qtVqvVarVaLSTEAMVicTqdIAg4HA4EAgE4HI5EIoFA4HA4jEYjpVLJZDLZ7Xa/328ymcRiMa/X+3g8JpMJj8djMpmMRqNarXa73Wq1yo8/sQGlh4I+EVoAAAAASUVORK5CYII=',
    'US': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIoSURBVEhLzZbNSxtRFMfPzC+SfsAkaWqTRm2w0Yqg4KVIUSxYCIo/gqC14FeQIlY8eBGsVItgKyIqUWy0FGxsb4g2aWwyD+nEzp2Z+XGO78BJJmF3Z3Ye+OW9eO/lfb7He296vV5vKBR6p10ul9vtdqVSqVAo1Gq1wWDw+/0ajcZisfC7AEqlUqvVCgQCWq3W6/UajcZut1ssFu/3+/l8LhaLZrNZLBbz+Xy9Xq/RaDQajVqtVqlUCoVCsVhsNputVqs1m00mk0KhUCgUarVaLBaLx+NZLJa/LwCHw2EymYxGo1ar1el0Wq1Wm81ms9kqlcqgX8vlcpVK5XA4VCoVCoVyuVwqlUqlUqvVWq3W6/V6vV4oFFqtxmAwGI1GoVCorFarVCrVarVaEAQGg0Gr1Wo0GpvNJhaLxWJRrVabzWa1Wm02m8VisVgs5vP5er1eLBaLxWLT6XQ6nXA4HIlEIpEIj8djMplMJpNer9fr9Xq9XigUEgqFZrPZbDar1WqxWGw2m9VqNRaLMRgMNptNoVCoVqvVajVBEBAEAoFALBYLBAIsFovBYDAYDEaj0Wq1Wq3W7XZ7vd4fHh7u7u7u7+8fHx8fHx/Pz8/v7+/39/e7u7vDw8N+v1+v12s0GpvNJhQKhUKhUqlUKpXquq5pmgwGg9FohEIhFAqxWKy7u/vDw8P9/f3x8fH8/Pz+/v5er9doNFqtVqlUKpWKxWKx2+12u10ul4vF4uHh4f7+/vj4+Pz8/P7+/l6v12q1Wq1WqVRqtVq1Wq3X6xUKhVAoFAqFarXq+/0+nU5BEAgEAoFAqNVqvV6v0+kEQSAQCALBEBqNRqPRarVaLJaPjw/v93t/f398fHx8fHx8fHx8fP/8/v78/v78/vH48fjw8PDw8PDw8HB3d3d3d3d3d3d3d3d3d3ePjw8PDw8fHx8fHx8fHx/f3x8fHx/f3x8f3x8f3//98P//8f//v+d3/n8AE7u/27pU1tYAAAAASUVORK5CYII=',
    'GB': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIBSURBVEhLzZbNSxthGMfP3P+I/QGttIKp2oNFCyIoKHoQFPQgKAj+BwTBR7DgQQQtYsGCS1AUbFSLIqjdS6st1m1bW4y1TW1ySE69u3Pm/Jzje5aTMNmdkxl45fd453ne5/t4Z/r9fp/P582m0+l0OBwqlQoEAsFgMFqtVq/XO/wXoN1u12q12+12uVwqlQoEAoFisZgCQDAYDLa3t9PT0zMzM0tLS9vb2+FwGAQCeTyeTCZisVgsFguFQqPRCAQCgUAoFAqFQqFQKBQKRQKBoNFohEIhFAqFQqEymYxGo1AoFAqFQqPRaDQaDAYDAwM7OzuLi4uDg4MrKyuDgoJgMKhUKpvNJhaLhUKh0+lcLpeDweByuZqamsLCwrS0NCgoKCgoyMrKmpqaDg8P5+fnNzc3Jycny8vLS0tLk5OTk5OTR0dHc3Nz8/PzTU1Nvb29gYGBTU1Nra2tTU1Nra2tra2tjY2Nzc3Nzc3Nzc3Nzc3NzczM7OzsDQ0NbW1t5eXlycnJ8vLybW1tTU1NPT09cXFxenp6enp6enp6bGxsfHx8cXFxenp6bGxsfHx8fHx8cnJycnJycnJydHR0dHR0dHR0cnJyc3Nze3t7a2trc3NzcnJydHR0dHR0dHR0dHR0dHR0cnJyc3Nzf39/f39/b29vc3Nzc3Nzc3Nze3t7b29vf39/f39/f39/f39/f39/f3//f3//f3//f3//f3//f39/b29vc3NzAwMDIyMjMzMzS0tLa2trGxsbe3t7e3t7e3t7e3t7e3t7e3t7e3t7e3v/f39/f39/f3//f3//f3//f3+fz+dms/mH6vV6oVAIBAKBQCDodruFQqFarXa7XavVKhQKhULxer2hUMgQCKRer/e7oNlsisVi3gAymUxms1ksFovFYrlczmaz2WxGo1Eul/M+4HA4HA6Hw+F0Oh0Oh4PBYDAajUajoVAoVCoVCsVgMBgMBoPBaDQajUaj0WhEIpFAIJBIJBKJBEHgOA6JRAKBwOVy2Ww2m83m83lBEAgEXiAQEATxeDyerxMIhMfj8Xg8Ho/HYrH4fL5YLAYCQSAQCAQCpVLpdDpBEAgEAqVSCYVCrVar1Wo1Go1CoVCr1Wq1WoVCIVuN8fv7W/h4AAAAAElFTkSuQmCC',
    'CA': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHySURBVEhLzZbLSsNQFIYnnGkv2FiI/QnEjaCtYFfBiwjiRUEtKghYEYoC/oEg+Ao8aFFrxYJgK7goCFZELNoiFi3SJNlJ5s2bC+IHzCQzc+b8J2fOnDk0Go2FQqEn2ng83m63W61WqVRarVZBEARB8Hg8Wq1Wq9W63e6/AdBut1utVqvVajweD4fDYDAYDAbr9fputxMIBKVSabVaL5fLZrPpdDqdTqfT6XQ6nVKpVKlUKpVKpVKpUqlUKpXJZDAYDAaDwWQymUwmk8nkcDh8Pp/P5/P5fDwej8fj8Xg8Ho/HYrFYLBbL5bLarFar1Wq1Wq1Wq1QqpVJptVoBAIBgMBgMhsqllMvlVqvVZrPpdLpcLpfLBYfDYDAYDAaDweDxeDwej8fj8Xg8Hs/nc7lcrlar1Wq1Wq1Wq1UqlUqpdDoFAACZTKaTSaVSGY1GoVDw+/1+v5/P54vFIhaLxWJRrVZ7vd4fHh7u7u7u7+/39/ePj4/v7+/n5+d3d3ePjw97vd5qtYpEIhaLxeLxer2eTCaTyWQymUxmsxEEQRDwer0+n08oFEql0mq1+nw+n8/ndrudz+dzudyurq7n5+dHR0cXFxcXFxdnZ2dnZ2dnZ2dnZ2cPDw9PT08vLy8vLy8PDw8PDw9fX19fX19fX19fX19fX19fX19fX19PT08PDw9BEARB8Hq9PZ5/d4kI50Xn83kAAAAASUVORK5CYII=',
    'AU': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAHwSURBVEhLzZbNThtREIWnv/YfCAkSIpA0lJA4SChcOKSccIJwA5wApyA5Aa4AcQJyAvwB4qSgQAlIGhYSoAQIEvI/2rOePWPstS0s4pHsO9b1++yZndV8Ph8Oh4N/y2KxGAwGk8lksVhcLpder9dpdJ1O12g0Bv8WqNVqvV6vUqkwGAwGg0Eul1ssllarFQqFHMdBEJRKpXw+n8/ny+UyCALhcBgEgiAIgiAIgiAIgud5HMflcrlYLKbz+Wy1WhRFURQFAOB5HgiCwWAwGAzZbLa6urr9+/dfunTpzJkzZ86cOX/+fGZmZmlp6ebm5ubm5ujo6OjoadLS0tLS0tzc3Nzc3N7e3t/f39/f39/fPz8/n5+fPz8/Dw4ODg8PPz8/Pz8/v7+/f35+fn5+bm5uLi4uLi4uzs7Oz8/PX19fX19fn5+fn5+f39/f39/f39/f39/fDw8PDw8PT09PLy8vLy8vj4+Pj4+PT09PDw8PPz8/f39/f39/f39/f39/v7+/f35+np+fX1xcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcXFxcX-he-user-id`,
    'ES': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAADISURBVEhL7dHBDoJQFEXRkIAgQvAOiHDhEii4cO79D8EBlK7crgHiwIEiKCEiYgAd+8pCk7RJTb/pZDbJd8k+l80UvL6+vsk9vT/c3R5w6o309/V5v388PTvB+4Wv11d2eH68Xv97f394fHw8Pj+9/g7e/vj3+H65f3t6+fX78fnv45fXv8+fH36/vXw7+vvD68u/z68Xv9//T29vTw8PPz7/g1g6/0+vL+9fLw7vL8D2/16gYvXv19fP//7fP/7f/39+vXw7ev3z/fXl9fXw+vX3/+fH19/314eX98fXz5/vvx++Pr17//P3y/f746+X35/e3r/+/v7+P397f3l/f3j/9Xv/+Pz69/vv+8vH5/e//w+/Pz7+/Pn4+vn+8fP35+vP/4fLw9PTw9/Pz8/P/4/X759+P/9+fn18+//t6/fP98+P/1+/X36/fnx5+fn4+/Pz69/f/86+P/w9/n97f3r8+/H5+/Pz8//v5+//x+gHh6eXh6+fv1+/fz4+/n/7/vP/5+/P76+fv/8f3v4+/v7+/v7/gBw+vP75/vvz8/f/y+P/z6/ffz6/f/34/f/1+/P/8+vnx8/P/1+/P76/vvz+/vr6+/f/8+//z+/vz+/vz+/vz+/v7+/v7+/gC4/3/9+f7x+vXz9+fnz/e3/9/fnx9+P/5/f3t7+fn/8/31+/fz+/v35/v7+/vr6+/f/4/f/1+/v7/fHl8fXz5+/Pz6/fvz7+/v7+/v7+/AOD94+f3t4/f3z7+fn/8/vr+8f/z6+f3x9e3/1+/v7/fP98+f/1+/v/4/vHz9+f7x+/Xz9+fnz/e3v4/f358ffj/+f397e/n5//P99fv38/v79+f7+/v76+/f/4/f/16/v/6+Pn/+f/z6/f/34/f/1+/f/4+vnx8/f/6/fP99ff/5/fX19/f37/+f/z+/v7+/v7+/AOj94+f3t4/f3z7+fn/8/vr+8f/z6+f3x9e3/1+/v7/fP98+f/1+/v/4/vHz9+f7x+/Xz9+fnz/e3v4/f358ffj/+f397e/n5//P99fv38/v79+f7+/v76+/f/4/f/16/v/6+Pn/+f/z6/f/34/f/1+/f/4+vnx8/f/6/fP99ff/5/fX19/f37/+f/z+/v7+/v7+/AAAAAElFTkSuQmCC',
    'MX': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIBSURBVEhLzZbNSxtRGMfPjCgqgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKC//2wCEAAoHCBYWFRgWFhYZGRgaHBwcHBwYGhwcHBwaHBocHBweHh4cIS4lHCErIRwcJjgmKy8xNTU1GiQ7QDs0Py40NTEBDAwMEA8QHhISHzQrJCs0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NP/AABEIAKkBNgMBIgACEQEDEQH/xAAYAAEBAQEBAAAAAAAAAAAAAAAAAQIDBf/EAB4QAQEBAQEBAQEBAQEAAAAAAABEQISAxMhQVFh/8QAGQEBAQEBAQEAAAAAAAAAAAAAAAECAwQG/8QAFhEBAQEAAAAAAAAAAAAAAAAAABEB/9oADAMBAAIRAxEAAAD4AAAAEigAAAAAIsAAAAAEUAAAAAAAAAAAAgqUAAAAAAAABCpQAAAAAAAAAAAAgKAAAAAAAAAAAAEUAAAAAAAAAAAIqUAAAAAAACUAAAAACKgAAAAAAAACKlAAAAAAAAAAACKAAAAAAAAAAAAAAABFQAAAAAAAAAAAIqUAAAAAABCpQAAAAAAAACKlAAAAAAAACFQAAAAAAAAAAACKlAAAAAAAAACAAAAAAAAAAAAAIqUAAAAAIKgAAAAACKAAAAAAAABCpQAAAAAAAAgqAAAAAAAAAAAACKlAAAAAAAAAAAAAAgAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIKgAAAAAAACKlAAAAAAACKAAAAAAAABCpQAAAAAAAACKlAAAAAAgqAAAAAAIKlAAAAAACKAAAAAAAAAAgqUAAAAAIKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAIKgAAAAACKlAAAAAAAAAgqAAAAAAAAAAAACKlAAAAAAAAAAAAACKAAAAAAAACKlAAAAAgqUAAAAAAAIAAAAAAAACKlAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAAAIKgAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIKgAAAAAAACKlAAAAAAAACCoAAAAAAAAACCoAAAAAAAACCoAAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAACKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAAgqAAAAAAIKgAAAAAAACCoAAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAAgqAAAAAAAAAgqUAAAAAAAIAAAAAAAACCoAAAAAAAAAAgqAAAAAAAAACKlAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAACKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAIKgAAAAACKlAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAAAqUAAAAAAAIAAAACUAAAAAAAAAqUAAAAAAAAIKgAAAAAAgqUAAAAAAAIKgAAAAAAAAACCoAAAAAAAACCoAAAAAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAAAACCoAAAAAAAACCoAAAAAAAAAAgqUAAAAAAAIAAAAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAAAAACCoAAAAAAgqAAAAAAAAACKlAAAAAAAACCoAAAAAAgqUAAAAAAAIAAAAAAAAACKlAA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a2r1vWuS9q9q1r+xS/sM1q3Ja1uS9rc2eavW1e1uS5i3J29y/W9rVvWuWvW371uK3tWvW3Pa3JeuP2qWtyXtWtyWtatYta3NmvW1r1rWv6l7Xtatz1i3L2va/cva1a9bV729L1ua17/cti1rWte1r2vW1f+q/wCC8BmrVaxWtq3Ja1uazNaxatvWuS1a1a9LW9e1e1r1rXv1i3B69bX5rWte1+9a5L2tW9r1r1i1rVvW9cl7V7W569y9r2v61vX/uv6XrWv7F7Xv63tX/Xf2L1+3Ja1uWva3NazNmsWrb1rkvWte17Wr2vWtctatzXre1a1r2va17XrWva1b1rkvatz1r2vetaxWtq1/cuatctetv1rW9+e9et7/3V/bvWt6//AORasWsWta3tetq5L2tW9r1i1j/ANYK7LTMKUkzT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+oOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q5W0+kOVtPpDlbT6Q',
    'SA': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAIBSURBVEhLzZPLSxtRFMfP3C8iBv2AklJaKPEg6FE8eBEUPYgH/QkePEl6ELx58CBI9CCJeFAoFFrQVq0FpS0li7Y0tE2x2d35zuEkk7C7Mzu78MvLzcy595t5M2dGn8/n+zwtY19Z3Vb2n3D7Pj8P3s/vD/yY/yLg1NTX3Z6fC3t+e+PZ/f54aGvbS0tBPT3t/nB3d1q1l5fC+m8/fE5+3g6+P3z0+vvr0xM+tLWl/frqKlhZXn57/d3t7YPDYwcnJidGRjg4mRjY3d3c2NraWV9eAQcHE0lJycnpqa2tLSYmJiYnh8XjAjs6o/F4/Obm1t7eGRkZGhwc7OzqCgqKxWJR4VA4HJaUlBQWFtbe3p6amgoLC4Pj493dXd3d3dXVVb+/v7+/PxUVY2NjuVxOSUmJjIxOTExMTU0lJSX5+/vLy8uDg4PDwsLq6uqsra1hYWEymQyHw5KSknJzc7OzsxMTExcuXAgLCyvF4iIiIrFYLCYmJj4+XlxcjImJyc3NtbW1lZSUDA0NlZWVcXFxsVisvr6em5srLS2trKycnZ1tbW2VlZXV1dVJSUn5+fnp6emysoqJiSkpKXFzcycnJ2VlZXV1NeXl5ampqbGxsem5uYmJSVxcjIuLi4mJKSkpzc3NtbW1paWl5eXl5eVlZWVVVVVRUVEpKSkhIVFeXl5RUZGVlZWVk5OTk5MTE5PT09MTEzMzc0NDQ0NDY2NjU1NTc3Nzc3Nzc3t7e39/f3d3d3d3d3t4eHh4eHh7u7u7u7+8PDw/39/fPz8/Pz8/f39/f3+8fHx/Pz9fX1+vr6/v7e0eHh3/7+7x9/Prw8PDw8Pj4+Pz/f3x+P/4/vT09OTs7d3c3j8djY2N9fn4eHw+Pj4d/+/r+fn58fD/8fH76+v5/f/z+/vz68u7u8u7s/f/z+gM0eH7A9AAAAAElFTkSuQmCC',
    'EG': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYAQMAAACC/VnDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAGUExURQAAANg/ACz/wRoAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAcSURBVBjTYwACAShAMeAIYgGMAyBwIAAA1jUBYJ5mX5kAAAAASUVORK5CYII=',
    'FR': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYBAMAAABn1d9eAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAGUExURQAAAL3c/0Xw2gIAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAVSURBVBjTY2BAA7SAIAwZRAIA+4EB7mF5GIsAAAAASUVORK5CYII=',
    'AR': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAD4SURBVEhL7dFBCoAwEETRIUAcpQ6C+9+jIIKLODaYQY+l+rAlD0y3W25s1zVN0zR9qer6SjI9yvG43++3w+HweDy6riulVqv1er1YLL7v22w2m83G5/N5PB5FUZqmKaVSqVQaDodMJpPJZO5/BEEQBEEQBAEAgAAsyzLMsizL8n0/y7Isqz7r6+sDAwODg4MHDx6cnp5+8uTJ06dPnz59+vTpkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx58uTJkydPnjx5gAAAAASUVORK5CYII=',
    'IN': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAUCAYAAACaq43VAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAACNSURBVEhL7dHBCcAgEAPRTU93d3d3d3d3d3d3d3d39y4iE7iws/w7T1s3s2zLsizLmqarqqqqup5nYRgGg0Eul/P5vNlsisUiCALD4bDb7V6vl8/nB4NBERQKhVKp1Go1wzBqtVqj0Wg0GnW73W63y+VyOBxBEARBkMvler3e6XRBEARBkMvlhUKh3+8HAE3TJEnSNE0URVEUBQChUCh+v9/v9/P5fD6fD4fD4XDwer1eLpcDAE3TNE1RFMXzPMuybDa7y+UyGAym02m1WvV6vVgsxpgxxhhjzPO8LMuybBsOh8FgUKvVarWaIAiCILFYLJVKpVIpFApBEARBEAgEIpEIAoFAoVAoFAqFQqFQKBQKRQKBoNFohEIhFAqxWKy7u/vDw8P9/f3x8fH8/Pz+/v5er9doNFqtVqlUKpWKxWKx2+12u10ul4vF4uHh4f7+/vj4+Pz8/P7+/l6v12q1Wq1WqVRqtVq1Wq3X6xUKhVAoFAqFarXq+/0+nU5BEAgEAoFAqNVqvV6v0+kEQSAQCALBEBqNRqPRarVaLJaPjw/v93t/f398fHx8fHx8fHx8fP/8/v78/v78/vH48fjw8PDw8PDw8HB3d3d3d3d3d3d3d3d3d3ePjw8PDw8fHx8fHx8fHx/f3x8fHx/f3x8f3x8f3//98P//8f//v+d3/n8AE7u/27pU1tYAAAAASUVORK5CYII=',
    'IT': 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAYAQMAAACC/VnDAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAGUExURQAAAP//AMpgA+oAAAAJcEhZcwAADsMAAA7DAcdvqGQAAAAUSURBVBjTYwACAShAMeAIYgEA2sEBw+XWz4wAAAAASUVORK5CYII=',
};

const GIPHY_API_KEY = 'XJ2iV2QY2y87TE3m2s1a73E52yEa2A4h'; // Public key

// --- TYPE DEFINITIONS ---

// For Video Editor
interface VideoElement {
  id: string;
  type: 'flag' | 'text' | 'image' | 'gif' | 'cta';
  content: string; // Emoji, text, or base64 data URL
  x: number; // 0-100 percentage
  y: number; // 0-100 percentage
  size: number; // represents font size or image width
  // Text-specific styles
  color: string;
  bgColor: string;
  hasBg: boolean;
  fontFamily: string;
  fontWeight: string;
  fontStyle: string;
  textTransform: string;
  strokeColor: string;
  strokeWidth: number;
  hasStroke: boolean;
  // Image/GIF specific
  aspectRatio: number; // To maintain proportions
}

// For Image Creator
interface AnalysisResult {
    language: string;
    translation: string;
    text_elements: {
        title: string;
        points: string[];
        secondary_text: string[];
        cta: string;
    };
    visual_description: string;
}

// For Image Creator
interface GeneratedImage {
    src: string;
    translation?: string;
}

interface Subtitle {
    word: string;
    startTime: number;
    endTime: number;
    index: number;
    sentenceIndex: number;
}

interface NarrationVariation {
    audioBuffer: AudioBuffer | null;
    subtitles: Subtitle[];
    elements: VideoElement[];
}


// --- HELPER FUNCTIONS ---

const fileToGenerativePart = async (file: File) => {
    const base64EncodedDataPromise = new Promise<string>((resolve) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve((reader.result as string).split(',')[1]);
        reader.readAsDataURL(file);
    });
    return {
        inlineData: { data: await base64EncodedDataPromise, mimeType: file.type },
    };
};

function decodeBase64(base64: string) {
  const binaryString = atob(base64);
  const len = binaryString.length;
  const bytes = new Uint8Array(len);
  for (let i = 0; i < len; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}

async function decodePcmAudioData(
  data: Uint8Array,
  ctx: AudioContext,
  sampleRate: number = 24000,
  numChannels: number = 1,
): Promise<AudioBuffer> {
  const dataInt16 = new Int16Array(data.buffer);
  const frameCount = dataInt16.length / numChannels;
  const buffer = ctx.createBuffer(numChannels, frameCount, sampleRate);

  for (let channel = 0; channel < numChannels; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < frameCount; i++) {
      channelData[i] = dataInt16[i * numChannels + channel] / 32768.0;
    }
  }
  return buffer;
}

function writeString(view: DataView, offset: number, string: string) {
    for (let i = 0; i < string.length; i++) {
        view.setUint8(offset + i, string.charCodeAt(i));
    }
}

function pcmToWavBlob(pcmData: Uint8Array, sampleRate: number, numChannels: number, bitsPerSample: number): Blob {
    const dataSize = pcmData.length;
    const buffer = new ArrayBuffer(44 + dataSize);
    const view = new DataView(buffer);
    const blockAlign = numChannels * (bitsPerSample / 8);
    const byteRate = sampleRate * blockAlign;

    writeString(view, 0, 'RIFF');
    view.setUint32(4, 36 + dataSize, true);
    writeString(view, 8, 'WAVE');
    writeString(view, 12, 'fmt ');
    view.setUint32(16, 16, true);
    view.setUint16(20, 1, true); // PCM
    view.setUint16(22, numChannels, true);
    view.setUint32(24, sampleRate, true);
    view.setUint32(28, byteRate, true);
    view.setUint16(32, blockAlign, true);
    view.setUint16(34, bitsPerSample, true);
    writeString(view, 36, 'data');
    view.setUint32(40, dataSize, true);
    
    for (let i = 0; i < dataSize; i++) {
        view.setUint8(44 + i, pcmData[i]);
    }

    return new Blob([view], { type: 'audio/wav' });
}


// --- SVG ICONS ---

const VideoIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m22 8-6 4 6 4V8Z" /><rect width="14" height="12" x="2" y="6" rx="2" ry="2" /></svg>
);

const ImageIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect width="18" height="18" x="3" y="3" rx="2" ry="2" /><circle cx="9" cy="9" r="2" /><path d="m21 15-3.086-3.086a2 2 0 0 0-2.828 0L6 21" /></svg>
);

const UploadIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="1.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4" /><polyline points="17 8 12 3 7 8" /><line x1="12" x2="12" y1="3" y2="15" /></svg>
);

const WandIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="m21.64 3.64-1.28-1.28a1.21 1.21 0 0 0-1.72 0L2 18.12V22h3.88l14.76-14.76a1.21 1.21 0 0 0 0-1.72Z"/><path d="m14 7 3 3"/><path d="M5 6v4"/><path d="M19 14v4"/><path d="M10 2v2"/><path d="M7 8H3"/><path d="M21 16h-4"/><path d="M11 3H9"/></svg>
);

const GlobeIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>
);

const TrashIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...props}><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>
);

const ExportIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M12 17v-10"/><path d="m15 10-3-3-3 3"/><path d="M19 21H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h14c1.1 0 2 .9 2 2v14c0 1.1-.9 2-2 2z"/></svg>
);

const SpeakerOnIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path></svg>
);

const SpeakerOffIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="1" x2="1" y2="23"></line><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
);

const ChangeVideoIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><path d="M10.03 16.03 8 18l2.03-1.97"/><path d="M8 12.5v5.5"/><path d="m13.97 11.97 2.03-1.97L14 8"/><path d="M16 15.5v-5.5"/></svg>
);

const TextIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M17 6.1H7c-1.1 0-2 .9-2 2v7.8c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V8.1c0-1.1-.9-2-2-2z"></path><path d="M12 18v-5.5"></path><path d="M8 18v-5.5"></path><path d="M16 18v-5.5"></path><path d="M10 12.5h4"></path></svg>
);

const GalleryIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>
);

const GifIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M9 8.5h6m-6 7h4.5"/><path d="M16 8.5v7"/><path d="M6 15.5v-2.5c0-1.1.9-2 2-2h1.5"/><path d="M2 12C2 6.5 6.5 2 12 2s10 4.5 10 10-4.5 10-10 10S2 17.5 2 12z"/></svg>
);

const SubtitlesIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M21 15a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V9a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v6z"/><path d="M8 12h8"/><path d="M8 15h5"/></svg>
);

const NarrationIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/></svg>
);

const BoldIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/></svg>
);

const ItalicIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round" {...props}><line x1="19" y1="4" x2="10" y2="4"/><line x1="14" y1="20" x2="5" y2="20"/><line x1="15" y1="4" x2="9" y2="20"/></svg>
);

const CtaIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><path d="M16 4H8a4 4 0 0 0-4 4v8a4 4 0 0 0 4 4h8a4 4 0 0 0 4-4V8a4 4 0 0 0-4-4z"/><path d="m9 12 2 2 4-4"/></svg>
);

const InfoIcon = (props: React.SVGProps<SVGSVGElement>) => (
    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" {...props}><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>
);


// --- UI COMPONENTS ---
// These are smaller components used by the main feature modules.

/**
 * A modal component for searching and selecting GIFs from the GIPHY API.
 */
const GifPicker = ({ onSelect, onClose }: { onSelect: (file: File) => void, onClose: () => void }) => {
    const [searchTerm, setSearchTerm] = useState('');
    const [gifs, setGifs] = useState<any[]>([]);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const modalRef = useRef<HTMLDivElement>(null);

    const searchGifs = async () => {
        if (!searchTerm) return;
        setIsLoading(true);
        setError(null);
        try {
            const response = await fetch(`https://api.giphy.com/v1/gifs/search?api_key=${GIPHY_API_KEY}&q=${encodeURIComponent(searchTerm)}&limit=24&lang=pt`);
            if (!response.ok) throw new Error('A resposta da rede não foi bem-sucedida.');
            const data = await response.json();
            setGifs(data.data || []);
        } catch (err) {
            console.error(err);
            setError('Falha ao buscar GIFs. Tente novamente.');
        } finally {
            setIsLoading(false);
        }
    };

    const handleSelectGif = async (gif: any) => {
        setIsLoading(true);
        setError(null);
        try {
            const response = await fetch(gif.images.original.url);
            if (!response.ok) throw new Error('Não foi possível baixar o GIF.');
            const blob = await response.blob();
            const file = new File([blob], `${gif.id}.gif`, { type: 'image/gif' });
            onSelect(file);
        } catch (err) {
            console.error(err);
            setError('Falha ao carregar o GIF selecionado.');
        } finally {
            setIsLoading(false);
        }
    };

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (modalRef.current && !modalRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [onClose]);

    return (
        <div className="gif-picker-overlay">
            <div className="gif-picker-modal" ref={modalRef}>
                <h3>Buscar GIFs no GIPHY</h3>
                <div className="gif-search-bar">
                    <input
                        type="text"
                        value={searchTerm}
                        onChange={e => setSearchTerm(e.target.value)}
                        onKeyDown={e => e.key === 'Enter' && searchGifs()}
                        placeholder="Pesquisar..."
                        autoFocus
                    />
                    <button onClick={searchGifs} disabled={isLoading || !searchTerm}>
                        {isLoading ? <div className="spinner-small"></div> : 'Buscar'}
                    </button>
                </div>
                <div className="gif-results-grid">
                    {!isLoading && gifs.length === 0 && <p className='placeholder'>Digite algo para buscar GIFs.</p>}
                    {isLoading && <div className="spinner"></div>}
                    {error && <p className="error-message">{error}</p>}
                    {gifs.map(gif => (
                        <div key={gif.id} className="gif-item" onClick={() => handleSelectGif(gif)}>
                            <img
                                src={gif.images.fixed_width.url}
                                alt={gif.title}
                            />
                        </div>
                    ))}
                </div>
                <button className="close-btn" onClick={onClose}>Fechar</button>
            </div>
        </div>
    );
};

/**
 * A modal for generating a video caption using an AI prompt.
 */
const AICaptionModal = ({ onGenerate, onClose, isLoading }: { onGenerate: (prompt: string) => Promise<void>, onClose: () => void, isLoading: boolean }) => {
    const [prompt, setPrompt] = useState('');
    const modalRef = useRef<HTMLDivElement>(null);
    
    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (modalRef.current && !modalRef.current.contains(event.target as Node)) {
                onClose();
            }
        };
        document.addEventListener('mousedown', handleClickOutside);
        return () => {
            document.removeEventListener('mousedown', handleClickOutside);
        };
    }, [onClose]);

    const handleGenerate = () => {
        if (!prompt.trim() || isLoading) return;
        onGenerate(prompt);
    }

    return (
        <div className="gif-picker-overlay">
            <div className="gif-picker-modal" ref={modalRef} style={{maxWidth: '500px'}}>
                <h3>Gerar Legenda com IA</h3>
                <p style={{color: 'var(--text-secondary)', fontSize: '0.9rem', marginBottom: '0.5rem'}}>Descreva a ideia ou o conteúdo do seu vídeo, e a IA criará uma legenda para você.</p>
                <textarea
                    value={prompt}
                    onChange={(e) => setPrompt(e.target.value)}
                    placeholder="Ex: um vídeo de um cachorro correndo feliz na praia ao pôr do sol."
                    rows={4}
                    style={{width: '100%', marginBottom: '1rem', resize: 'none'}}
                    autoFocus
                />
                <div style={{display: 'flex', justifyContent: 'flex-end', gap: '0.5rem'}}>
                    <button className="close-btn" onClick={onClose} disabled={isLoading}>Cancelar</button>
                    <button onClick={handleGenerate} disabled={isLoading || !prompt.trim()}>
                        {isLoading ? <div className="spinner-small"></div> : 'Gerar'}
                    </button>
                </div>
            </div>
        </div>
    )
}

// --- FEATURE MODULES ---
// These are the main, high-level features of the application.

/**
 * The Image Creator module.
 * Analyzes a reference creative and generates AI-powered variations.
 */
const ImageCreator = () => {
    const [referenceFile, setReferenceFile] = useState<File | null>(null);
    const [referencePreview, setReferencePreview] = useState<string | null>(null);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [analysis, setAnalysis] = useState<AnalysisResult | null>(null);
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [generatedImages, setGeneratedImages] = useState<GeneratedImage[]>([]);
    const ai = useMemo(() => new GoogleGenAI({ apiKey: import.meta.env.VITE_GEMINI_API_KEY }), []);

    const resetState = () => {
        setReferenceFile(null);
        setReferencePreview(null);
        setIsAnalyzing(false);
        setAnalysis(null);
        setIsLoading(false);
        setError(null);
        setGeneratedImages([]);
    };

    const analyzeCreative = async (file: File) => {
        resetState();
        setReferenceFile(file);
        setReferencePreview(URL.createObjectURL(file));
        setIsAnalyzing(true);
        setError(null);

        try {
            const imagePart = await fileToGenerativePart(file);
            const analysisSchema = {
                type: Type.OBJECT,
                properties: {
                    language: { type: Type.STRING, description: "O código ISO 639-1 para o idioma detectado do texto na imagem (ex: 'en', 'pt', 'es')." },
                    translation: { type: Type.STRING, description: "Se o idioma não for Português ('pt'), forneça uma tradução completa e precisa de todo o texto para o Português do Brasil. Caso contrário, retorne uma string vazia." },
                    text_elements: {
                        type: Type.OBJECT,
                        description: "Um objeto contendo o texto extraído, categorizado por sua função no anúncio.",
                        properties: {
                            title: { type: Type.STRING, description: "O título ou manchete principal do anúncio." },
                            points: { type: Type.ARRAY, description: "Uma lista de pontos-chave ou características.", items: { type: Type.STRING } },
                            secondary_text: { type: Type.ARRAY, description: "Quaisquer linhas secundárias de texto ou subtítulos.", items: { type: Type.STRING } },
                            cta: { type: Type.STRING, description: "A chamada para ação (call to action) final." }
                        },
                        required: ['title', 'points', 'secondary_text', 'cta']
                    },
                    visual_description: { type: Type.STRING, description: "Uma descrição detalhada do estilo visual do anúncio, incluindo fundo, cores, fontes e atmosfera geral. Exemplo: 'Design minimalista com fundo de gradiente cinza claro e padrões de penas. O título usa uma fonte serifada vermelha e em negrito. Os pontos usam uma fonte sans-serif preta padrão. O texto secundário está em azul.'" }
                },
                required: ['language', 'translation', 'text_elements', 'visual_description']
            };

            const prompt = "Analise este criativo de anúncio. Extraia todos os elementos de texto e categorize-os. Descreva o estilo visual, cores e tema. Se o texto não estiver em Português do Brasil, traduza-o. Retorne o resultado como um objeto JSON.";

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: { parts: [imagePart, { text: prompt }] },
                config: {
                    responseMimeType: "application/json",
                    responseSchema: analysisSchema
                }
            });

            const result = JSON.parse(response.text) as AnalysisResult;
            setAnalysis(result);

        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : 'Falha ao analisar o criativo.');
            setAnalysis(null);
        } finally {
            setIsAnalyzing(false);
        }
    };

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            analyzeCreative(file);
        }
    };

    const generateVariations = async () => {
        if (!analysis) {
            setError('A análise do criativo deve ser concluída antes de gerar variações.');
            return;
        }

        setIsLoading(true);
        setError(null);
        setGeneratedImages([]);

        try {
            const { visual_description, text_elements, language } = analysis;
            const originalLanguageName = new Intl.DisplayNames(['pt-BR'], { type: 'language' }).of(language) || language;
            
            // --- ETAPA 1: Gerar novas variações de texto corrigidas primeiro ---
            const copyGenerationSchema = {
                type: Type.OBJECT,
                properties: {
                    variations: {
                        type: Type.ARRAY,
                        description: "Um array de 4 variações distintas de texto de anúncio.",
                        items: {
                            type: Type.OBJECT,
                            properties: {
                                title: { type: Type.STRING, description: "O novo título cativante." },
                                points: { type: Type.ARRAY, items: { type: Type.STRING }, description: "Uma lista de pontos-chave ou características." },
                                cta: { type: Type.STRING, description: "A chamada para ação final." }
                            },
                            required: ['title', 'points', 'cta']
                        }
                    }
                },
                required: ['variations']
            };

            const copyPrompt = `
                Analisando o seguinte texto de um anúncio, sua primeira tarefa é identificar e corrigir quaisquer erros de ortografia ou gramática.
                Depois, com base na mensagem corrigida, crie 4 novas variações de copy (texto publicitário).

                **Texto Original (para correção e inspiração):**
                - Idioma: ${originalLanguageName} (${language})
                - Título: "${text_elements.title}"
                - Pontos-chave: ${text_elements.points.map(p => `"${p}"`).join(', ')}
                - CTA: "${text_elements.cta}"

                **Requisitos para as 4 Variações:**
                1. **Idioma:** Todas as variações DEVEM estar em ${originalLanguageName}.
                2. **Qualidade:** O texto deve ser gramaticalmente perfeito, persuasivo e profissional.
                3. **Estrutura:** Mantenha uma estrutura semelhante (título, ${text_elements.points.length > 0 ? text_elements.points.length : 'alguns'} pontos, cta).
                4. **Originalidade:** As variações devem ser distintas umas das outras.

                Retorne um objeto JSON contendo as 4 variações.
            `;

            const textResponse = await ai.models.generateContent({
                model: 'gemini-2.5-pro', // Usar um modelo mais robusto para copywriting
                contents: { parts: [{ text: copyPrompt }] },
                config: {
                    responseMimeType: "application/json",
                    responseSchema: copyGenerationSchema,
                }
            });
            
            const result = JSON.parse(textResponse.text);
            const copyVariations = result.variations;

            if (!copyVariations || copyVariations.length === 0) {
                throw new Error("A IA não conseguiu gerar variações de texto.");
            }

            // --- ETAPA 2: Gerar uma imagem para cada variação de texto ---
            const imageGenerationPromises = copyVariations.slice(0, 4).map((copy: any) => {
                const imagePrompt = `
                    Crie um criativo de anúncio profissional e moderno com uma imagem de fundo relevante.
                    **Descrição Visual de Referência:** "${visual_description}". Crie um novo design inspirado nisso, mas não idêntico.
                    
                    **Incorpore o seguinte texto na imagem de forma clara, legível e com boa hierarquia visual:**
                    - **Título (destaque principal):** "${copy.title}"
                    - **Pontos-chave:** ${copy.points.map((p:string) => `\n  - ${p}`).join('')}
                    - **Call to Action (CTA):** "${copy.cta}"

                    **Requisitos CRÍTICOS:**
                    - A imagem DEVE ter uma proporção de **1:1 (quadrada)**.
                    - TODO o texto renderizado na imagem deve ser **exatamente** como fornecido, sem erros de ortografia.
                    - Organize os elementos de forma limpa e profissional.
                `;
                
                return ai.models.generateContent({
                    model: 'gemini-2.5-flash-image',
                    contents: { parts: [{ text: imagePrompt }] },
                    config: {
                        responseModalities: [Modality.IMAGE],
                    },
                });
            });

            const imageResponses = await Promise.all(imageGenerationPromises);

            const images = imageResponses.flatMap(response =>
                (response.candidates?.[0]?.content?.parts ?? [])
                    .filter(part => part.inlineData)
                    .map(part => `data:${part.inlineData!.mimeType};base64,${part.inlineData!.data}`)
            );


            if (!images || images.length === 0) {
                throw new Error("A IA não conseguiu gerar imagens de variação.");
            }

            if (language !== 'pt') {
                const generatedImageAnalysisSchema = {
                    type: Type.OBJECT,
                    properties: {
                         translation_pt_br: { type: Type.STRING, description: "Uma tradução precisa do texto extraído para o Português do Brasil, com quebras de linha (\\n) para manter a formatação original." }
                    },
                    required: ['translation_pt_br']
                };
                
                const imagesWithData = await Promise.all(images.map(async (imgSrc) => {
                    try {
                        const imagePart = { inlineData: { data: imgSrc.split(',')[1], mimeType: 'image/png' } };
                        const translationPrompt = "Extraia todo o texto desta imagem e traduza-o para o Português do Brasil, preservando as quebras de linha originais. Se não houver texto, retorne strings vazias.";
                        
                        const translationResponse = await ai.models.generateContent({
                            model: 'gemini-2.5-flash',
                            contents: { parts: [imagePart, { text: translationPrompt }] },
                            config: {
                                responseMimeType: "application/json",
                                responseSchema: generatedImageAnalysisSchema
                            }
                        });

                        const result = JSON.parse(translationResponse.text);
                        return {
                            src: imgSrc,
                            translation: result.translation_pt_br
                        };
                    } catch (e) {
                        console.error("Falha ao traduzir a imagem gerada:", e);
                        return { src: imgSrc, translation: 'Não foi possível traduzir o texto.' };
                    }
                }));
                setGeneratedImages(imagesWithData);
            } else {
                setGeneratedImages(images.map(src => ({ src, translation: '' })));
            }
        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : 'Ocorreu um erro desconhecido ao gerar variações.');
        } finally {
            setIsLoading(false);
        }
    };
    
    const exportCreative = (imageUrl: string) => {
        const link = document.createElement('a');
        link.download = `creative-variation-${Date.now()}.png`;
        link.href = imageUrl;
        link.click();
    };

    return (
        <div className="module-container">
            <header className="module-header">
                <h1>Gerador de Variações de Criativos</h1>
                <p>Envie um criativo de referência para análise e gere múltiplas variações para testes A/B.</p>
            </header>
            <div className="content-wrapper">
                <div className="input-section">
                    <h2>1. Envie seu Criativo</h2>
                    <div className="dropzone">
                        <input type="file" id="file-upload" accept="image/*" onChange={handleFileChange} />
                        <label htmlFor="file-upload" style={{ opacity: isAnalyzing ? 0.5 : 1 }}>
                            <UploadIcon />
                            <span>Clique para selecionar ou arraste uma imagem</span>
                            <small>JPG, PNG, WebP</small>
                        </label>
                    </div>

                    {isAnalyzing && (
                        <div className="analysis-placeholder">
                            <div className="spinner"></div>
                            <p>Analisando criativo...</p>
                        </div>
                    )}
                    
                    {referencePreview && !isAnalyzing && (
                        <div className="analysis-section">
                            <div className="reference-preview">
                                <img src={referencePreview} alt="Criativo de Referência" />
                            </div>
                            {error && <p className="error-message">{error}</p>}
                            {analysis && (
                                <div className="analysis-results">
                                    <h3>2. Análise do Criativo</h3>
                                    {analysis.language !== 'pt' && analysis.translation && (
                                        <div className="analysis-card">
                                            <strong>Tradução ({analysis.language}):</strong>
                                            <p>{analysis.translation}</p>
                                        </div>
                                    )}
                                    <div className="analysis-card">
                                        <strong>Texto Extraído:</strong>
                                        <ul>
                                            <li><strong>Título:</strong> {analysis.text_elements.title}</li>
                                            {analysis.text_elements.points.map((p, i) => <li key={i}>- {p}</li>)}
                                            {analysis.text_elements.secondary_text.map((p, i) => <li key={i}>- {p}</li>)}
                                            <li><strong>CTA:</strong> {analysis.text_elements.cta}</li>
                                        </ul>
                                    </div>
                                    <button onClick={generateVariations} disabled={isLoading}>
                                        {isLoading ? 'Gerando...' : '3. Gerar Variações'}
                                    </button>
                                </div>
                            )}
                        </div>
                    )}
                </div>

                <div className="output-section">
                    <h2>Variações Geradas</h2>
                    <div className="output-content">
                        {isLoading && <div className="spinner"></div>}
                        {!isLoading && generatedImages.length === 0 && (
                            <p className="placeholder">Suas variações aparecerão aqui...</p>
                        )}
                        {generatedImages.length > 0 && (
                             <div className="variations-grid">
                                {generatedImages.map((img, index) => (
                                    <div key={index} className="creative-card">
                                        <div className="creative-image-container">
                                            <img src={img.src} alt={`Variação de criativo ${index + 1}`} />
                                            <button className="export-creative-btn" onClick={() => exportCreative(img.src)} title="Exportar Variação">
                                                <ExportIcon />
                                            </button>
                                        </div>
                                        {img.translation && (
                                            <div className="translation-card">
                                                <strong>Tradução:</strong>
                                                <p className="translation-text">{img.translation}</p>
                                            </div>
                                        )}
                                    </div>
                                ))}
                            </div>
                        )}
                    </div>
                </div>
            </div>
        </div>
    );
};

/**
 * The Video Editor module.
 * Allows users to upload a video and overlay text, images, and GIFs.
 * Includes AI features for generating content.
 */
const VideoEditor = () => {
    const [videoFile, setVideoFile] = useState<File | null>(null);
    const [videoUrl, setVideoUrl] = useState<string | null>(null);
    const [elements, setElements] = useState<VideoElement[]>([]);
    const [selectedElementId, setSelectedElementId] = useState<string | null>(null);
    const [countryPrompt, setCountryPrompt] = useState('');
    
    const [isLoading, setIsLoading] = useState(false);
    const [error, setError] = useState<string | null>(null);
    const [aspectRatio, setAspectRatio] = useState('9 / 16');
    const [isMuted, setIsMuted] = useState(false);
    const [isFontPickerOpen, setIsFontPickerOpen] = useState(false);
    const [isGifPickerOpen, setIsGifPickerOpen] = useState(false);

    const [isExporting, setIsExporting] = useState(false);
    const [exportProgress, setExportProgress] = useState(0);
    const [exportMessage, setExportMessage] = useState('');
    
    const [draggingElement, setDraggingElement] = useState<{id: string, initialX: number, initialY: number, mouseInitialX: number, mouseInitialY: number} | null>(null);
    const [resizingElement, setResizingElement] = useState<{id: string, initialSize: number, mouseInitialX: number, mouseInitialY: number} | null>(null);
    const [isCaptionModalOpen, setIsCaptionModalOpen] = useState(false);
    const [isGeneratingCaption, setIsGeneratingCaption] = useState(false);

    const videoRef = useRef<HTMLVideoElement>(null);
    const videoWrapperRef = useRef<HTMLDivElement>(null);
    const imageInputRef = useRef<HTMLInputElement>(null);
    const gifInputRef = useRef<HTMLInputElement>(null);
    const changeVideoInputRef = useRef<HTMLInputElement>(null);
    const elementImageCache = useRef<Map<string, HTMLImageElement>>(new Map());
    const fontPickerRef = useRef<HTMLDivElement>(null);

    const ai = useMemo(() => new GoogleGenAI({ apiKey: import.meta.env.VITE_GEMINI_API_KEY }), []);

    const selectedElement = useMemo(() => {
        return elements.find(el => el.id === selectedElementId) || null;
    }, [elements, selectedElementId]);

    useEffect(() => {
        // Cleanup for the video URL when it changes
        return () => {
            if (videoUrl) URL.revokeObjectURL(videoUrl);
        };
    }, [videoUrl]);
    
    useEffect(() => {
        const handleMouseMove = (e: MouseEvent) => {
            if (draggingElement && videoWrapperRef.current) {
                const rect = videoWrapperRef.current.getBoundingClientRect();
                const x = ((e.clientX - rect.left) / rect.width) * 100;
                const y = ((e.clientY - rect.top) / rect.height) * 100;

                updateElement(draggingElement.id, {
                    x: Math.max(0, Math.min(100, x)),
                    y: Math.max(0, Math.min(100, y))
                });
            }

            if (resizingElement && videoWrapperRef.current) {
                const dx = e.clientX - resizingElement.mouseInitialX;
                const newSize = Math.max(20, resizingElement.initialSize + dx * 2); 
                updateElement(resizingElement.id, { size: newSize });
            }
        };
    
        const handleMouseUp = () => {
            setDraggingElement(null);
            setResizingElement(null);
        };
    
        window.addEventListener('mousemove', handleMouseMove);
        window.addEventListener('mouseup', handleMouseUp);
    
        return () => {
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
        };
    }, [draggingElement, resizingElement]);

    useEffect(() => {
        if (videoRef.current) {
            videoRef.current.muted = isMuted;
        }
    }, [isMuted]);

    useEffect(() => {
        const handleClickOutside = (event: MouseEvent) => {
            if (fontPickerRef.current && !fontPickerRef.current.contains(event.target as Node)) {
                setIsFontPickerOpen(false);
            }
        };
        document.addEventListener("mousedown", handleClickOutside);
        return () => document.removeEventListener("mousedown", handleClickOutside);
    }, [fontPickerRef]);

    const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {
        const file = event.target.files?.[0];
        if (file) {
            if (videoUrl) {
                URL.revokeObjectURL(videoUrl);
            }
            setVideoFile(file);
            setVideoUrl(URL.createObjectURL(file));
            setError(null);
        }
        if (event.target) {
            event.target.value = '';
        }
    };

    const generateCountryElements = async () => {
        if (!countryPrompt) return;

        setIsLoading(true);
        setError(null);
        try {
            const infoSchema = {
              type: Type.OBJECT,
              properties: {
                flag: { type: Type.STRING, description: "O emoji da bandeira do país. Apenas o emoji." },
                currencyName: { type: Type.STRING, description: "O nome da moeda local do país." },
                attractiveValue: { type: Type.NUMBER, description: "Um valor monetário baixo, mas atraente, que as pessoas poderiam ganhar por uma tarefa simples, como assistir a um vídeo. Por exemplo, 3, 5 ou 10." },
                cta: { type: Type.STRING, description: "Um call-to-action curto, como 'Por Vídeo!' ou 'Por Tarefa!'." }
              },
              required: ['flag', 'currencyName', 'attractiveValue', 'cta']
            };

            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: `Para o país "${countryPrompt}", forneça informações para uma sobreposição de vídeo. Preciso do emoji da bandeira, o nome da moeda local, um valor monetário atraente para ganhar por uma pequena tarefa e um call-to-action.`,
                config: {
                    responseMimeType: "application/json",
                    responseSchema: infoSchema
                }
            });
            
            const info = JSON.parse(response.text);
            const newElements: VideoElement[] = [];

            if (info.flag && typeof info.flag === 'string' && info.flag.trim() !== '') {
                const flagElement: VideoElement = {
                    id: uuidv4(),
                    type: 'flag',
                    content: info.flag, x: 25, y: 15, size: 48,
                    color: '#FFFFFF', hasBg: false, bgColor: 'transparent',
                    fontFamily: 'sans-serif', textTransform: 'none',
                    hasStroke: false, strokeColor: '#000000', strokeWidth: 2,
                    aspectRatio: 1, fontWeight: '400', fontStyle: 'normal'
                };
                newElements.push(flagElement);
            } else {
                console.warn("API did not provide a valid flag emoji for:", countryPrompt);
            }

            const textContent = `${info.attractiveValue} ${info.currencyName} ${info.cta}`;
            const textElement: VideoElement = {
                id: uuidv4(),
                type: 'text', content: textContent,
                x: 60, y: 15, size: 30,
                color: '#FFFFFF', bgColor: '#000000', hasBg: true,
                fontFamily: "'Anton', sans-serif", textTransform: 'uppercase',
                hasStroke: false, strokeColor: '#000000', strokeWidth: 2,
                aspectRatio: 1, fontWeight: '600', fontStyle: 'normal'
            };
            newElements.push(textElement);
            
            setElements(prev => [...prev, ...newElements]);
            setCountryPrompt('');

        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : 'Falha ao gerar informações do país.');
        } finally {
            setIsLoading(false);
        }
    };
    
    const addElement = (type: 'text' | 'image' | 'gif', options: { file?: File, content?: string } = {}) => {
        const { file, content } = options;
    
        if (type === 'text') {
            const newElement: VideoElement = {
                id: uuidv4(), type: 'text', content: content || 'Edite-me',
                x: 50, y: 50, size: 40,
                color: '#FFFFFF', hasBg: true, bgColor: '#000000',
                fontFamily: "'Anton', sans-serif", textTransform: 'uppercase',
                hasStroke: false, strokeColor: '#000000', strokeWidth: 2, aspectRatio: 1,
                fontWeight: '600', fontStyle: 'normal'
            };
             setElements(prev => [...prev, newElement]);
            setSelectedElementId(newElement.id);
        } else if (file) {
            const reader = new FileReader();
            reader.onload = () => {
                const base64Url = reader.result as string;
                const img = new Image();
                img.src = base64Url;
                img.onload = () => {
                    const newImageElement: VideoElement = {
                        id: uuidv4(), type: type, content: base64Url,
                        x: 50, y: 50, size: 150,
                        aspectRatio: img.width / img.height,
                        color: '', hasBg: false, bgColor: '', fontFamily: '', textTransform: '',
                        hasStroke: false, strokeColor: '', strokeWidth: 0,
                        fontWeight: '400', fontStyle: 'normal'
                    };
                    setElements(prev => [...prev, newImageElement]);
                    setSelectedElementId(newImageElement.id);
                };
            };
            reader.readAsDataURL(file);
        }
    };
    
    const handleMediaUpload = (event: React.ChangeEvent<HTMLInputElement>, type: 'image' | 'gif') => {
        const file = event.target.files?.[0];
        if (file) {
            addElement(type, { file });
        }
        event.target.value = '';
    };

    const handleSelectGif = (file: File) => {
        addElement('gif', { file });
        setIsGifPickerOpen(false);
    };

    const removeElement = (id: string) => {
        setElements(prev => prev.filter(el => el.id !== id));
        if (selectedElementId === id) {
            setSelectedElementId(null);
        }
    };
    
    const updateElement = (id: string, updates: Partial<VideoElement>) => {
        setElements(prev => prev.map(el => el.id === id ? { ...el, ...updates } : el));
    };

    const handleElementMouseDown = (e: React.MouseEvent<HTMLDivElement | HTMLImageElement>, id: string) => {
        setSelectedElementId(id);
        const el = elements.find(elem => elem.id === id);
        if (el) {
            setDraggingElement({
                id,
                initialX: el.x,
                initialY: el.y,
                mouseInitialX: e.clientX,
                mouseInitialY: e.clientY
            });
        }
        e.stopPropagation();
    };

    const handleResizeMouseDown = (e: React.MouseEvent<HTMLDivElement>, id: string) => {
        e.preventDefault();
        e.stopPropagation();
        const el = elements.find(elem => elem.id === id);
        if (el) {
            setSelectedElementId(id);
            setResizingElement({
                id,
                initialSize: el.size,
                mouseInitialX: e.clientX,
                mouseInitialY: e.clientY
            });
        }
    };

    const generateCaption = async (prompt: string) => {
        setIsGeneratingCaption(true);
        setError(null);
        try {
            const response = await ai.models.generateContent({
                model: 'gemini-2.5-flash',
                contents: `Gere uma legenda curta e impactante para um vídeo com a seguinte descrição: "${prompt}". A legenda deve ter no máximo 15 palavras. Retorne apenas o texto da legenda.`,
            });
            addElement('text', { content: response.text });
            setIsCaptionModalOpen(false);
        } catch (err) {
            console.error(err);
            setError(err instanceof Error ? err.message : 'Falha ao gerar legenda.');
        } finally {
            setIsGeneratingCaption(false);
        }
    };

    const exportVideo = async () => {
        if (!videoRef.current || !videoFile) {
            setError('Nenhum vídeo para exportar.');
            return;
        }

        setIsExporting(true);
        setExportProgress(0);
        setExportMessage('Preparando recursos...');
        setError(null);

        const imageElements = elements.filter(el => el.type === 'image' || el.type === 'gif');
        const imageLoadPromises = imageElements.map(el => {
            return new Promise<void>((resolve, reject) => {
                if (elementImageCache.current.has(el.id)) {
                    resolve();
                    return;
                }
                const img = new Image();
                img.src = el.content;
                img.onload = () => {
                    elementImageCache.current.set(el.id, img);
                    resolve();
                };
                img.onerror = () => reject(new Error(`Falha ao carregar imagem: ${el.content.substring(0, 50)}...`));
            });
        });
        
        try {
            await Promise.all(imageLoadPromises);
        } catch (error) {
            console.error(error);
            setError('Falha ao carregar uma das imagens para exportação.');
            setIsExporting(false);
            return;
        }

        setExportMessage('Iniciando exportação...');
    
        const videoElement = videoRef.current;
        const canvas = document.createElement('canvas');
        canvas.width = videoElement.videoWidth;
        canvas.height = videoElement.videoHeight;
        const ctx = canvas.getContext('2d');
    
        if (!ctx) {
            setError('Falha ao iniciar o canvas para renderização.');
            setIsExporting(false);
            return;
        }
    
        const videoStream = canvas.captureStream(30); 
        
        if (!isMuted) {
             try {
                // @ts-ignore
                const audioStream = videoElement.captureStream ? videoElement.captureStream() : (videoElement.mozCaptureStream ? videoElement.mozCaptureStream() : null);
                if (audioStream) {
                    const audioTracks = audioStream.getAudioTracks();
                    if (audioTracks.length > 0) {
                        videoStream.addTrack(audioTracks[0]);
                    }
                }
             } catch (e) {
                 console.error("Não foi possível capturar la faixa de áudio.", e);
             }
        }
        
        const { mimeType, extension } = (() => {
            const mp4MimeType = 'video/mp4; codecs=avc1.42E01E,mp4a.40.2';
            if (MediaRecorder.isTypeSupported(mp4MimeType)) {
                return { mimeType: mp4MimeType, extension: 'mp4' };
            }
            return { mimeType: 'video/webm; codecs=vp8,opus', extension: 'webm' };
        })();
        
        const recorder = new MediaRecorder(videoStream, { 
            mimeType: mimeType,
            videoBitsPerSecond: 8000000 // 8 Mbps for better quality
        });
        const chunks: Blob[] = [];
        
        const originalMutedState = videoElement.muted;
        const originalVolume = videoElement.volume;
        const originalTime = videoElement.currentTime;
        
        recorder.ondataavailable = e => chunks.push(e.data);
        recorder.onstop = () => {
            const blobMimeType = mimeType.split(';')[0];
            const blob = new Blob(chunks, { type: blobMimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `video_editado_${Date.now()}.${extension}`;
            a.click();
            URL.revokeObjectURL(url);
            
            setIsExporting(false);
            setExportMessage('');
            videoElement.currentTime = originalTime;
            videoElement.muted = originalMutedState;
            videoElement.volume = originalVolume;
            videoElement.pause();
        };
    
        let animationFrameId: number;
        const renderFrame = () => {
            if (videoElement.paused || videoElement.ended) {
                recorder.stop();
                cancelAnimationFrame(animationFrameId);
                return;
            }
    
            ctx.drawImage(videoElement, 0, 0, canvas.width, canvas.height);
    
            elements.forEach(el => {
                const x = (el.x / 100) * canvas.width;
                const y = (el.y / 100) * canvas.height;

                if (el.type === 'text' || el.type === 'flag') {
                    const scaledFontSize = Math.round(el.size * (canvas.height / 500));
                    ctx.font = `${el.fontStyle} ${el.fontWeight} ${scaledFontSize}px ${el.fontFamily}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';

                    let content = el.content;
                    if (el.textTransform === 'uppercase') {
                        content = content.toUpperCase();
                    }

                    if (el.type === 'flag') {
                        ctx.shadowColor = "rgba(0,0,0,0.6)";
                        ctx.shadowBlur = 5;
                        ctx.shadowOffsetY = 2;
                        ctx.fillStyle = el.color;
                        ctx.fillText(content, x, y);
                        ctx.shadowColor = 'transparent';
                        ctx.shadowBlur = 0;
                        ctx.shadowOffsetY = 0;
                        return;
                    }

                    const lines = content.split('\n');
                    const lineHeight = scaledFontSize * 1.2;

                    if (el.hasBg) {
                        const padding = scaledFontSize * 0.2;
                        let maxWidth = 0;
                        lines.forEach(line => {
                            const metrics = ctx.measureText(line);
                            if (metrics.width > maxWidth) {
                                maxWidth = metrics.width;
                            }
                        });

                        const totalTextHeight = (lines.length - 1) * lineHeight + scaledFontSize;
                        
                        ctx.fillStyle = el.bgColor;
                        ctx.fillRect(
                            x - maxWidth / 2 - padding, 
                            y - totalTextHeight / 2 - padding, 
                            maxWidth + padding * 2, 
                            totalTextHeight + padding * 2
                        );
                    }

                    ctx.fillStyle = el.color;
                    if (el.hasStroke && el.strokeWidth > 0) {
                        ctx.strokeStyle = el.strokeColor;
                        ctx.lineWidth = el.strokeWidth * (canvas.height / 500);
                    }

                    const startY = y - ((lines.length - 1) / 2) * lineHeight;

                    lines.forEach((line, index) => {
                        const currentY = startY + (index * lineHeight);
                        if (el.hasStroke && el.strokeWidth > 0) {
                            ctx.strokeText(line, x, currentY);
                        }
                        ctx.fillText(line, x, currentY);
                    });

                } else if (el.type === 'image' || el.type === 'gif') {
                    const img = elementImageCache.current.get(el.id);
                    const wrapperWidth = videoWrapperRef.current?.clientWidth;
                    if (img && wrapperWidth && wrapperWidth > 0) {
                        const scaledWidth = (el.size / wrapperWidth) * canvas.width;
                        const scaledHeight = scaledWidth / el.aspectRatio;
                        ctx.drawImage(img, x - scaledWidth / 2, y - scaledHeight / 2, scaledWidth, scaledHeight);
                    }
                }
            });
            
            const progress = Math.round((videoElement.currentTime / videoElement.duration) * 100);
            setExportProgress(progress);
            setExportMessage(`Renderizando: ${progress}%`);
    
            animationFrameId = requestAnimationFrame(renderFrame);
        };
        
        videoElement.currentTime = 0;
        if (isMuted) {
            videoElement.muted = true;
        } else {
            videoElement.muted = false;
            videoElement.volume = 0; // Mute audibly for the user, but not for capture
        }

        videoElement.play().then(() => {
            recorder.start();
            renderFrame();
        }).catch(e => {
            console.error("Playback failed:", e);
            setError("Não foi possível iniciar a reprodução do vídeo para exportação.");
            setIsExporting(false);
        });
    };

    return (
      <div className="module-container video-editor">
        {isExporting && (
            <div className="export-overlay">
                <div className="export-modal">
                    <h2>Exportando Vídeo</h2>
                    <p>{exportMessage}</p>
                    <div className="progress-bar-container">
                        <div className="progress-bar" style={{ width: `${exportProgress}%` }}></div>
                    </div>
                    <p>{exportProgress}%</p>
                </div>
            </div>
        )}
        {isGifPickerOpen && (
            <GifPicker
                onSelect={handleSelectGif}
                onClose={() => setIsGifPickerOpen(false)}
            />
        )}
        {isCaptionModalOpen && (
            <AICaptionModal
                isLoading={isGeneratingCaption}
                onClose={() => setIsCaptionModalOpen(false)}
                onGenerate={generateCaption}
            />
        )}
        {!videoUrl ? (
          <div className="video-upload-container">
            <h1>Editor de Vídeo com IA</h1>
            <p>Envie um vídeo e adicione textos, imagens e GIFs com facilidade.</p>
            <div className="dropzone">
              <input type="file" id="video-upload" accept="video/mp4,video/webm,video/quicktime" onChange={handleFileChange} />
              <label htmlFor="video-upload">
                <UploadIcon />
                <span>Clique para selecionar ou arraste um vídeo</span>
                <small>MP4, WebM, MOV</small>
              </label>
            </div>
            {error && <p className="error-message">{error}</p>}
          </div>
        ) : (
          <div className="editor-layout">
            <div className="player-section" onClick={() => setSelectedElementId(null)}>
                <div className={`device-preview aspect-${aspectRatio.replace(/ \/ /g, '')}`}>
                    <div className="video-wrapper" style={{ aspectRatio }} ref={videoWrapperRef}>
                        <video
                            key={videoUrl}
                            ref={videoRef}
                            src={videoUrl}
                            controls
                        />
                        <div className="elements-overlay">
                            {elements.map(el => (
                                <div
                                    key={el.id}
                                    className={`video-element-wrapper ${selectedElementId === el.id ? 'selected' : ''}`}
                                    style={{
                                        position: 'absolute',
                                        left: `${el.x}%`,
                                        top: `${el.y}%`,
                                        transform: 'translate(-50%, -50%)',
                                        width: (el.type === 'image' || el.type === 'gif') ? `${el.size}px` : 'auto',
                                        height: (el.type === 'image' || el.type === 'gif') ? `${el.size / el.aspectRatio}px` : 'auto',
                                        textAlign: 'center',
                                    }}
                                    onMouseDown={(e) => handleElementMouseDown(e, el.id)}
                                >
                                    { (el.type === 'text' || el.type === 'flag') && (
                                        <span className="video-element-text" style={{
                                            fontSize: `${el.size}px`,
                                            color: el.color,
                                            fontFamily: el.fontFamily,
                                            fontWeight: el.fontWeight,
                                            fontStyle: el.fontStyle,
                                            textTransform: el.textTransform as any,
                                            backgroundColor: el.hasBg ? el.bgColor : 'transparent',
                                            padding: el.hasBg ? '0.2em 0.4em' : '0',
                                            borderRadius: '4px',
                                            whiteSpace: 'pre-wrap',
                                            WebkitTextStroke: el.hasStroke ? `${el.strokeWidth}px ${el.strokeColor}` : 'unset',
                                        }}>
                                            {el.content}
                                        </span>
                                    )}
                                    { (el.type === 'image' || el.type === 'gif') && (
                                        <img src={el.content} className="video-element-media" alt="Elemento de vídeo" draggable="false" />
                                    )}
                                    { selectedElementId === el.id && (el.type === 'image' || el.type === 'gif') && (
                                        <div 
                                            className="resize-handle"
                                            onMouseDown={(e) => handleResizeMouseDown(e, el.id)}
                                        ></div>
                                    )}
                                </div>
                            ))}
                        </div>
                    </div>
                </div>
            </div>
            <div className="controls-section">
                <h2>Controles</h2>
                <div className="control-group">
                    <h3><VideoIcon /> Vídeo</h3>
                    <div className="video-controls">
                        <button onClick={() => setIsMuted(!isMuted)}>
                            {isMuted ? <SpeakerOffIcon /> : <SpeakerOnIcon />}
                            <span>{isMuted ? 'Ativar Som' : 'Silenciar'}</span>
                        </button>
                        <input 
                            type="file" 
                            ref={changeVideoInputRef} 
                            onChange={handleFileChange} 
                            accept="video/mp4,video/webm,video/quicktime" 
                            style={{display: 'none'}} 
                        />
                        <button onClick={() => changeVideoInputRef.current?.click()}>
                            <ChangeVideoIcon />
                            <span>Trocar Vídeo</span>
                        </button>
                    </div>
                </div>

                <div className="control-group">
                    <h3>Adicionar Elementos</h3>
                    <div className="add-elements-controls">
                        <button onClick={() => addElement('text')}><TextIcon /> <span>Texto</span></button>
                        <input type="file" ref={imageInputRef} onChange={(e) => handleMediaUpload(e, 'image')} accept="image/png, image/jpeg" style={{display: 'none'}} />
                        <button onClick={() => imageInputRef.current?.click()}><GalleryIcon /> <span>Imagem</span></button>
                        <input type="file" ref={gifInputRef} onChange={(e) => handleMediaUpload(e, 'gif')} accept="image/gif" style={{display: 'none'}} />
                        <button onClick={() => setIsGifPickerOpen(true)}><GifIcon/> <span>GIF</span></button>
                    </div>
                </div>
                
                <div className="control-group">
                    <h3><WandIcon style={{stroke: 'currentColor'}}/> Ferramentas de IA</h3>
                     <button onClick={() => setIsCaptionModalOpen(true)} disabled={isLoading || isGeneratingCaption}>
                        <SubtitlesIcon />
                        <span>Gerar Legendas</span>
                    </button>
                    <div className="prompt-group">
                        <select
                            value={countryPrompt}
                            onChange={(e) => setCountryPrompt(e.target.value)}
                        >
                            <option value="">Selecione um país</option>
                            {Object.entries(LANGUAGE_TO_COUNTRIES_MAP).map(([langCode, countries]) => (
                                <optgroup key={langCode} label={LANGUAGES[langCode]?.name || langCode.toUpperCase()}>
                                    {countries.map(country => (
                                        <option key={country.code} value={country.name}>
                                            {country.name}
                                        </option>
                                    ))}
                                </optgroup>
                            ))}
                        </select>
                        <button onClick={generateCountryElements} disabled={isLoading || !countryPrompt}>
                            {isLoading ? <div className="spinner-small"></div> : <GlobeIcon />}
                        </button>
                    </div>
                    {error && <p className="error-message">{error}</p>}
                </div>

                 <div className="control-group">
                     <h3><ImageIcon /> Camadas</h3>
                    <div className="elements-list">
                        {elements.map(el => (
                            <div key={el.id} className={`element-item ${selectedElementId === el.id ? 'selected' : ''}`} onClick={() => setSelectedElementId(el.id)}>
                                <span>{el.type === 'flag' ? 'Bandeira' : el.type === 'text' ? 'Texto' : el.type === 'image' ? 'Imagem' : 'GIF'}: {el.type === 'text' || el.type === 'flag' ? el.content : el.id.substring(0,6)}</span>
                                <button className="delete-btn" onClick={(e) => { e.stopPropagation(); removeElement(el.id); }}><TrashIcon /></button>
                            </div>
                        ))}
                         {elements.length === 0 && <small>Nenhum elemento adicionado.</small>}
                    </div>
                </div>

                {selectedElement && (
                <div className="control-group">
                    <h3>Estilo do Elemento</h3>
                    {(selectedElement.type === 'text') && (
                        <div className="style-control" style={{flexWrap: 'wrap', gap: '0.5rem'}}>
                            <label htmlFor="element-text-content" style={{width: '100%'}}>Conteúdo do Texto</label>
                            <textarea
                                id="element-text-content"
                                value={selectedElement.content}
                                onChange={e => updateElement(selectedElementId!, { content: e.target.value })}
                                rows={3}
                                style={{width: '100%'}}
                            />
                        </div>
                    )}
                    <div className="style-control">
                        <label>Tamanho</label>
                        <input type="range" min="12" max={selectedElement.type === 'text' || selectedElement.type === 'flag' ? "100" : "500"} value={selectedElement.size} onChange={e => updateElement(selectedElementId!, { size: parseInt(e.target.value) })} />
                        <span>{selectedElement.size}px</span>
                    </div>
                    {(selectedElement.type === 'text' || selectedElement.type === 'flag') && <>
                        <div className="style-control">
                            <label>Cor do Texto</label>
                            <input type="color" value={selectedElement.color} onChange={e => updateElement(selectedElementId!, { color: e.target.value })} />
                        </div>
                        <div className="style-control">
                            <label>Fonte</label>
                            <div className="custom-select" ref={fontPickerRef}>
                                <button
                                    className="select-button"
                                    style={{ fontFamily: selectedElement.fontFamily }}
                                    onClick={() => setIsFontPickerOpen(prev => !prev)}
                                >
                                    {FONT_FAMILIES.find(f => f.value === selectedElement.fontFamily)?.name || 'Inter'}
                                </button>
                                {isFontPickerOpen && (
                                    <ul className="options">
                                        {FONT_FAMILIES.map(font => (
                                            <li
                                                key={font.value}
                                                style={{ fontFamily: font.value }}
                                                onMouseDown={() => {
                                                    updateElement(selectedElementId!, { fontFamily: font.value });
                                                    setIsFontPickerOpen(false);
                                                }}
                                            >
                                                {font.name}
                                            </li>
                                        ))}
                                    </ul>
                                )}
                            </div>
                        </div>
                        <div className="style-control">
                            <label>Caixa</label>
                            <select value={selectedElement.textTransform} onChange={e => updateElement(selectedElementId!, { textTransform: e.target.value })}>
                                <option value="uppercase">MAIÚSCULAS</option>
                                <option value="none">Normal</option>
                            </select>
                        </div>
                        <div className="style-control toggle">
                            <label>Fundo</label>
                            <input type="checkbox" id="hasBg" checked={selectedElement.hasBg} onChange={e => updateElement(selectedElementId!, { hasBg: e.target.checked })} />
                            {selectedElement.hasBg && <input type="color" value={selectedElement.bgColor} onChange={e => updateElement(selectedElementId!, { bgColor: e.target.value })} />}
                        </div>
                        <div className="style-control toggle">
                            <label>Borda</label>
                            <input type="checkbox" id="hasStroke" checked={selectedElement.hasStroke} onChange={e => updateElement(selectedElementId!, { hasStroke: e.target.checked })} />
                            {selectedElement.hasStroke && <input type="color" value={selectedElement.strokeColor} onChange={e => updateElement(selectedElementId!, { strokeColor: e.target.value })} />}
                        </div>
                        {selectedElement.hasStroke && <div className="style-control">
                            <label>Espessura</label>
                             <input type="range" min="1" max="10" value={selectedElement.strokeWidth} onChange={e => updateElement(selectedElementId!, { strokeWidth: parseInt(e.target.value) })} />
                             <span>{selectedElement.strokeWidth}px</span>
                        </div>}
                    </>}
                </div>
                )}
                 <div className="control-group">
                    <h3>Formato (Preview)</h3>
                    <div className="aspect-ratios">
                        <button className={aspectRatio === '9 / 16' ? 'active' : ''} onClick={() => setAspectRatio('9 / 16')}>Reels/Stories</button>
                        <button className={aspectRatio === '1 / 1' ? 'active' : ''} onClick={() => setAspectRatio('1 / 1')}>Quadrado</button>
                        <button className={aspectRatio === '4 / 5' ? 'active' : ''} onClick={() => setAspectRatio('4 / 5')}>Retrato</button>
                        <button className={aspectRatio === '16 / 9' ? 'active' : ''} onClick={() => setAspectRatio('16 / 9')}>Widescreen</button>
                    </div>
                </div>
                <div className="control-group">
                     <h3><ExportIcon /> Exportar</h3>
                     <button onClick={exportVideo} disabled={isExporting}>
                        {isExporting ? 'Exportando...' : 'Exportar Vídeo'}
                     </button>
                </div>
            </div>
          </div>
        )}
      </div>
    );
};

/**
 * The Video Narrator module.
 * Allows users to upload a video, add subtitles, and generate AI narration.
 */
const VideoNarrator = () => {
    const [videoFile, setVideoFile] = useState<File | null>(null);
    const [videoUrl, setVideoUrl] = useState<string | null>(null);
    const [elements, setElements] = useState<VideoElement[]>([]); // For non-subtitle elements like images/CTA
    const [selectedElementId, setSelectedElementId] = useState<string | null>(null);

    // Narration and Subtitle state
    const [narrationScript, setNarrationScript] = useState('');
    const [selectedVoice, setSelectedVoice] = useState(VOICES[0].id);
    const [selectedLanguages, setSelectedLanguages] = useState<string[]>(['pt']);
    const [selected